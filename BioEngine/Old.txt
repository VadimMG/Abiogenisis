/*
function randomInt(n) {
    return Math.floor(Math.random() * n);
}
*/

/*
function angleA(angle) {
    this.value = angle % 360;
}

angleA.prototype.add = function (add) {
    var newAng = this.value + add;
    this.value = newAng % 360;
}

angleA.prototype.setAngle = function (angle) {
    var newAng = angle % 360;
    this.value = newAng;
}
*/

function fatty(x, y, angle = 0, id) {
    this.name = "fatty";
    this.x = x;
    this.y = y;
    this.vel = .5//more like speed if angle is sperate
    this.radius = 1;
    this.angle = new angleA(angle);//xvel and yvel instead of angle
    //this.oAngle = angle;
    this.length = 16;
    this.remove = false;
    this.id = id;
    this.isfocus = false;
}

fatty.prototype.render = function (ctx) {
    var testAng = this.angle.value + 180;
    var cos = Math.cos(testAng * Math.PI / 180);
    var sin = Math.sin(testAng * Math.PI / 180);

    ctx.fillStyle = "white";
    ctx.strokeStyle = "black";

    var tempx1 = ((this.x - (this.length / 2) * c.scale) - this.x) *c.scale;
    var tempx2 = ((this.x + (this.length / 2) * c.scale) - this.x) *c.scale;
    var tempx3 = ((this.x + (this.length / 2) * c.scale) - this.x) *c.scale;
    var tempx4 = ((this.x - (this.length / 2) * c.scale) - this.x) *c.scale;

    var tempy1 = ((this.y - this.radius * c.scale) - this.y) *c.scale;
    var tempy2 = ((this.y - this.radius * c.scale) - this.y) *c.scale;
    var tempy3 = ((this.y + this.radius * c.scale) - this.y) *c.scale;
    var tempy4 = ((this.y + this.radius * c.scale) - this.y) *c.scale;

    var finalx1 = (tempx1 * cos - tempy1 * sin + this.x);
    var finalx2 = (tempx2 * cos - tempy2 * sin + this.x);
    var finalx3 = (tempx3 * cos - tempy3 * sin + this.x);
    var finalx4 = (tempx4 * cos - tempy4 * sin + this.x);

    var finaly1 = (tempx1 * sin + tempy1 * cos + this.y);
    var finaly2 = (tempx2 * sin + tempy2 * cos + this.y);
    var finaly3 = (tempx3 * sin + tempy3 * cos + this.y);
    var finaly4 = (tempx4 * sin + tempy4 * cos + this.y);

    var head = new Path2D();
    var tail = new Path2D();
    var body = new Path2D();

    head.arc((finalx2 + finalx3) / 2 *c.scale - c.x, (finaly2 + finaly3) / 2 *c.scale - c.y, this.radius * 4 * c.scale, 0, Math.PI * 2);
    tail.arc((finalx4 + finalx1) / 2 *c.scale - c.x, (finaly4 + finaly1) / 2 *c.scale - c.y, this.radius * c.scale, 0, Math.PI * 2);

    body.moveTo(finalx1 *c.scale - c.x, finaly1 *c.scale - c.y);
    body.lineTo(finalx2 *c.scale - c.x, finaly2 *c.scale- c.y);
    body.lineTo(finalx3 *c.scale- c.x, finaly3 *c.scale- c.y);
    body.lineTo(finalx4 *c.scale- c.x, finaly4 *c.scale- c.y);
    body.lineTo(finalx1 *c.scale- c.x, finaly1 *c.scale- c.y);

    ctx.fillStyle = "goldenrod";
    ctx.fill(body);
    ctx.fill(tail);

    ctx.fillStyle = "white";
    ctx.stroke(head);
    ctx.fill(head);

    if (this.isfocus) {
        var label = new Path2D();
        label.arc(this.x *c.scale - c.x, this.y *c.scale - c.y, this.length/2 * c.scale, 0, Math.PI * 2);
        ctx.stroke(label);
    }
}

fatty.prototype.tick = function (entities) {
    for (var i = 0; i < entities.length; i++) {
        var e = entities[i];
        if (e != this && e.name == "fatty") {
            var xdist = e.getTailX()- this.getTailX();
            var ydist = e.getTailY() - this.getTailY();
            var dist = Calc.distance(this.getTailX(), this.getTailY(), e.getTailX(), e.getTailY());
            if (dist != 0) {
                var ang = Math.atan2(ydist, xdist) * 180 / Math.PI;
                var mag = 40 * 1 * 1 / (dist * dist);
                this.actForce(ang, mag);
            } else {
                //console.log("need someting");
            }
            
        }
    }
   
    this.x += Math.cos(this.angle.value * Math.PI / 180) * this.vel;
    this.y += Math.sin(this.angle.value * Math.PI / 180) * this.vel;

    for (var i = 0; i < entities.length; i++) {
        var e = entities[i];
        if (e != this && e.name == "fatty") {
            if (this.isCollide(e)) {

                //seperate by moving both apart...
                //opostie directions, overlap distacne and angle...

                e.x += Math.cos(this.angle.value * Math.PI / 180) * this.vel;
                e.y += Math.sin(this.angle.value * Math.PI / 180) * this.vel

                /*
                var angTemp = this.angle.value;
                var velTemp = this.vel;
                this.angle.setAngle(e.angle.value);
                this.vel = e.vel;

                e.angle.setAngle(angTemp);
                e.vel = velTemp;
                */

                //this.x -= Math.cos(this.angle.value * Math.PI / 180) * this.vel;
                //this.y -= Math.sin(this.angle.value * Math.PI / 180) * this.vel;
            }
        }
    }

    if (this.x < 0) {
        //this.x = 0;
        this.x = 600;
        //this.angle.add(180);
    }
    if (this.x > 600) {
        //this.x = 600;
        this.x = 0;
        //this.angle.add(180);
    }
    if (this.y < 0) {
        //this.y = 0;
        this.y = 600;
        //this.angle.add(180);
    }
    if (this.y > 600) {
        //this.y = 600;
        this.y = 0
        //this.angle.add(180);
    }
}

fatty.prototype.actForce = function (angle, mag) {//divide force by mass
    var xvel = Math.cos(this.angle.value * Math.PI / 180) * this.vel;
    var yvel = Math.sin(this.angle.value * Math.PI / 180) * this.vel;

    var newxvel = Math.cos(angle * Math.PI / 180) * mag;
    var newyvel = Math.sin(angle * Math.PI / 180) * mag;

    if (this.isfocus) {
        //console.log(xvel, yvel, this.angle.value, this.vel, Math.atan2(yvel, xvel) * 180/ Math.PI);
    }

    xvel += newxvel;
    yvel += newyvel;

    if (xvel != 0 && yvel != 0) {
        var newAng =  new angleA(Math.atan2(yvel, xvel) * 180/ Math.PI);
        var newmag = Math.sqrt(xvel * xvel + yvel * yvel);
        this.angle.setAngle(newAng.value);
        this.vel = newmag % 1;
        //console.log(this.vel);
    } else {
        this.vel = 0;
    }

}

fatty.prototype.setVel = function (vel) {
    this.vel = vel;
}

fatty.prototype.setAngle = function (angle) {
    this.angle.setAngle(angle);
}

fatty.prototype.isCollide = function (other) {
    if (distance(this.getHeadX(), this.getHeadY(), other.getHeadX(), other.getHeadY()) <= this.radius * 4 + other.radius * 4 ||
        distance(this.getHeadX(), this.getHeadY(), other.getTailX(), other.getTailY()) <= this.radius * 4 + other.radius ||
        distance(this.getHeadX(), this.getHeadY(), other.x, other.y) <= this.radius * 4 + other.radius) {
        //console.log("head collison");
        return true;
    }

    if (distance(this.x, this.y, other.getHeadX(), other.getHeadY()) <= this.radius + other.radius * 4 ||
        distance(this.x, this.y, other.getTailX(), other.getTailY()) <= this.radius + other.radius ||
        distance(this.x, this.y, other.x, other.y) <= this.radius + other.radius) {
        //console.log("center collison");
        return true;
    }

    if (distance(this.getTailX(), this.getTailY(), other.getHeadX(), other.getHeadY()) <= this.radius + other.radius * 4 ||
        distance(this.getTailX(), this.getTailY(), other.getTailX(), other.getTailY()) <= this.radius + other.radius ||
        distance(this.getTailX(), this.getTailY(), other.x, other.y) <= this.radius + other.radius) {
        //console.log("tail collison");
        return true;
    }
}

fatty.prototype.collide = function (other) {
    this.vel = -1;
    if (this.isCollide(other)) {
        this.vel = 1;
    }
}

fatty.prototype.getX = function () {
    return this.x;
}

fatty.prototype.getY = function () {
    return this.y;
}

//x = length/2 , y
fatty.prototype.getHeadX = function () {
    var tempy2 = (this.y - this.radius) - this.y;
    var tempy3 = (this.y + this.radius) - this.y;
    var tempx2 = (this.x + (this.length / 2)) - this.x;
    var tempx3 = (this.x + (this.length / 2)) - this.x;
    var cos = Math.cos(this.angle.value * Math.PI / 180);
    var sin = Math.sin(this.angle.value * Math.PI / 180);
    var finalx2 = tempx2 * cos - tempy2 * sin + this.x;
    var finalx3 = tempx3 * cos - tempy3 * sin + this.x;
    return (finalx2 + finalx3) / 2;
}

fatty.prototype.getHeadY = function () {
    var tempy2 = (this.y - this.radius) - this.y;
    var tempy3 = (this.y + this.radius) - this.y;
    var tempx2 = (this.x + (this.length / 2)) - this.x;
    var tempx3 = (this.x + (this.length / 2)) - this.x;
    var cos = Math.cos(this.angle.value * Math.PI / 180);
    var sin = Math.sin(this.angle.value * Math.PI / 180);
    var finaly2 = tempx2 * sin + tempy2 * cos + this.y;
    var finaly3 = tempx3 * sin + tempy3 * cos + this.y;
    return (finaly2 + finaly3) / 2;
}

fatty.prototype.getTailX = function () {//this.x +/- cos * length...
    var tempx1 = (this.x - (this.length / 2)) - this.x;
    var tempx4 = (this.x - (this.length / 2)) - this.x;
    var tempy1 = (this.y - this.radius) - this.y;
    var tempy4 = (this.y + this.radius) - this.y;
    var cos = Math.cos(this.angle.value * Math.PI / 180);
    var sin = Math.sin(this.angle.value * Math.PI / 180);
    var finalx1 = tempx1 * cos - tempy1 * sin + this.x;
    var finalx4 = tempx4 * cos - tempy4 * sin + this.x;
    return (finalx4 + finalx1) / 2;
}

fatty.prototype.getTailY = function () {
    var tempx1 = (this.x - (this.length / 2)) - this.x;
    var tempx4 = (this.x - (this.length / 2)) - this.x;
    var tempy1 = (this.y - this.radius) - this.y;
    var tempy4 = (this.y + this.radius) - this.y;
    var cos = Math.cos(this.angle.value * Math.PI / 180);
    var sin = Math.sin(this.angle.value * Math.PI / 180);
    var finaly1 = tempx1 * sin + tempy1 * cos + this.y;
    var finaly4 = tempx4 * sin + tempy4 * cos + this.y;
    var num = (finaly4 + finaly1) / 2;
    return num;
}

fatty.prototype.getRadius = function () {
    return this.radius;
}

fatty.prototype.getLength = function () {
    return this.length;
}

fatty.prototype.getAngle = function () {
    return this.angle.value;
}

fatty.prototype.getVel = function () {
    return this.vel;
}

fatty.prototype.getXVel = function () {
    var xvel = Math.cos(this.angle.value * Math.PI / 180) * this.vel;
    return xvel;
}

fatty.prototype.getYVel = function () {
    var yvel = Math.sin(this.angle.value * Math.PI / 180) * this.vel;
    return yvel;
}

fatty.prototype.getX = function() {
    return this.x;
}

fatty.prototype.getY = function() {
    return this.y;
}

fatty.prototype.isFocus = function() {
    return this.isfocus;
}

fatty.prototype.setFocus = function(newFocus) {
    this.isfocus = newFocus;
}

function distance(x1, y1, x2, y2) {
    var num = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
    return num;
}

/*
var MAXSPEED = 2;

var entity = function(x, y, angle, speed, id) {//width, length, radius... name?, game?
    console.log("entity called", x, y);
    this.x = x;
    this.y = y;
    this.angle = new Angle(angle);//legal?
    this.speed = speed;
    this.id = id;
    this.isRemove = false;
    this.focus = false;//same name as function?
    this.radius = 4;
    console.log(this.x, x, this.y ,y);
}

//Requried functions to be overriden

entity.prototype.render = function (ctx) {//to override
    console.log("Render called", this.x, this.y);
    if (this.focus) {
        ctx.fillStyle = "red";
    } else {
        ctx.fillStyle = "white";
    }
    
    var body = new Path2D();
    body.arc((this.x * c.scale - c.x), (this.y * c.scale- c.y), this.radius * c.scale, 0, 2 * Math.PI);

    ctx.fill(body);
}

entity.prototype.tick = function () {//pass in entites? or game, to override, game in constuctor?
   //if(this.id != 0) {
    this.x += this.getXvel();
    this.y += this.getYvel();
    //}
    //decrease speed with friction/drag
    //this.actForce((this.angle.getValue() + 180) % Calc.MAXDEGREE , .05 * 1 * (this.speed * this.speed) * 1 * 1);

    if (this.x < 0) {
        //this.x = 0;
        this.x = 600;
        //this.angle.add(180);
    }
    if (this.x > 600) {
        //this.x = 600;
        this.x = 0;
        //this.angle.add(180);
    }
    if (this.y < 0) {
        //this.y = 0;
        this.y = 600;
        //this.angle.add(180);
    }
    if (this.y > 600) {
        //this.y = 600;
        this.y = 0
        //this.angle.add(180);
    }
}

//Getters

entity.prototype.getX = function () {
    return this.x;
}

entity.prototype.getY = function () {
    return this.y;
}

entity.prototype.getAngle = function () {
    return this.angle.getValue();
}

entity.prototype.getSpeed = function () {
    return this.speed;
}

entity.prototype.getXvel = function () {
    return Math.cos(this.angle.getValue() * Calc.DEGTORAD) * this.speed;
}

entity.prototype.getYvel = function () {
    return Math.sin(this.angle.getValue() * Calc.DEGTORAD) * this.speed;
}

entity.prototype.isFocus = function () {
    return this.focus
}

//Setters

entity.prototype.setAngle = function (angle) {
    this.angle.setAngle(angle);
}

entity.prototype.setSpeed = function (speed) {
    this.speed = speed;
}

entity.prototype.setX = function (x) {
    this.x = x;
}

entity.prototype.setY = function () {
    this.y = y;
}

entity.prototype.setFocus = function(focus) {
    this.focus = focus;
}

//other functions

entity.prototype.actForce = function(angle, magnitue) {//degrees or radians
    var forceX = Math.cos(angle * Calc.DEGTORAD) * magnitue;
    var forceY = Math.sin(angle * Calc.DEGTORAD) * magnitue;

    var eXvel = this.getXvel();
    var eYvel = this.getYvel();

    eXvel += forceX;
    eYvel += forceY;

    if (eXvel != 0 && eYvel != 0) {
        var newAngle = Math.atan2(eYvel, eXvel);
        var newSpeed = Math.sqrt(eXvel * eXvel + eYvel * eYvel);//remove or bound to max
        this.angle.setValue(newAngle);
        this.speed = newSpeed % MAXSPEED;//remove or bound to max
    } else {
        this.speed = 0;
    }

}
*/

/*
function calc(){
    this.MAXDEGREE = 360;
    this.DEGTORAD = Math.PI / 180;
    this.RADTODEG = 180/ Math.PI;


    
    function distance(x1, y1, x2, y2) {
        var num = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
        return num;
    }
    
    //console.log(DEGTORAD);
}

calc.prototype.distance = function(x1, y1, x2, y2) {
    var num = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
    return num;
}


//calc.MAXDEGREE = 360;
//calc.DEGTORAD = Math.PI / 180;

var Calc = new calc();
*/

/*

function Angle(angle = 0) {//radians or degrees
    this.angle = angle % Calc.MAXDEGREE;
}

Angle.prototype.addValue = function (angle) {
    this.angle = (this.angle + angle) % Calc.MAXDEGREE;
}

Angle.prototype.setValue = function (angle) {
    this.angle = angle % Calc.MAXDEGREE;
}

Angle.prototype.getValue = function () {//radians or degrees
    return this.angle;
}

function rotateCoord(x, y, centerX, CenterY, angle) {
    //return x, y rotated around ox, o by angle
}

*/

/*
function randomInt(n) {
    return Math.floor(Math.random() * n);
}

function angleA(angle) {
    this.value = angle % 360;
}

angleA.prototype.add = function (add) {
    var newAng = this.value + add;
    this.value = newAng % 360;
}

angleA.prototype.setAngle = function (angle) {
    var newAng = angle % 360;
    this.value = newAng;
}

/*
types

Glycine	Yes	Yes	Yes	Yes
α-Alanine	Yes	Yes	Yes	Yes
β-Alanine	Yes	Yes	Yes	No
Aspartic acid	Yes	Yes	Yes	Yes
α-Aminobutyric acid	Yes	Yes	Yes	No
Serine	No	Yes	Yes	Yes
Isoserine	No	Yes	Yes	No
α-Aminoisobutyric acid	No	Yes	Yes	No
β-Aminoisobutyric acid	No	Yes	Yes	No
β-Aminobutyric acid	No	Yes	Yes	No
γ-Aminobutyric acid	No	Yes	Yes	No
Valine	No	Yes	Yes	Yes
Isovaline	No	Yes	Yes	No
Glutamic acid	No	Yes	Yes	Yes
Norvaline	No	Yes	No	No
α-Aminoadipic acid	No	Yes	No	No
Homoserine	No	Yes	No	No
2-Methylserine	No	Yes	No	No
β-Hydroxyaspartic acid	No	Yes	No	No
Ornithine	No	Yes	No	No
2-Methylglutamic acid	No	Yes	No	No
Phenylalanine	No	Yes	No	Yes
Homocysteic acid	No	No	Yes	No
S-methylcysteine	No	No	Yes	No
Methionine	No	No	Yes	Yes
Methionine sulfoxide	No	No	Yes	No
Methionine sulfone	No	No	Yes	No
Isoleucine	No	No	Yes	Yes
Leucine	No	No	Yes	Yes
Ethionine


function amino(x, y, angle = 0, id) {
    this.name = "amino"
    this.x =x;
    this.y =y;
    this.angle = new angleA(angle);
    this.id = id;
    this.radius = 4;
    this.width = 8;
    this.remove = false;
    this.vel = 1;
    this.isfocus = false;
}

amino.prototype.render = function(ctx) {//add border for astetics
    var amine = new Path2D();
    var carbox = new Path2D();
    var sidechain = new Path2D();

    ctx.fillStyle = "purple";

    amine.arc(this.x *c.scale - this.width/2 * c.scale - c.x, this.y *c.scale - c.y, this.radius * c.scale, 0, 2 * Math.PI);

    ctx.fill(amine);

    ctx.fillStyle = "white";

    carbox.arc(this.x *c.scale + this.width/2 * c.scale - c.x, this.y *c.scale - c.y, this.radius * c.scale, 0, 2 * Math.PI);

    ctx.fill(carbox);

    ctx.fillStyle = "red";

    sidechain.arc(this.x *c.scale - c.x, this.y *c.scale + this.width/2 * c.scale - c.y, this.radius * c.scale, 0, 2 * Math.PI);

    ctx.fill(sidechain);

    if (this.isfocus) {
        var label = new Path2D();
        label.arc(this.x *c.scale - c.x, this.y *c.scale - c.y, this.width/2 * c.scale, 0, Math.PI * 2);
        ctx.stroke(label);
    }    
}

amino.prototype.tick = function(entities) {

    for (var i = 0; i < entities.length; i++) {
        var e = entities[i];
        if (e != this && e.name == "amino") {
            var xdist = e.x - this.x;
            var ydist = e.y - this.y;
            var dist = distance(e.x, e.y, this.x, this.y);
            if (dist != 0) {
                var ang = Math.atan2(ydist, xdist) * 180 / Math.PI;
                var mag = 40 * 1 * 1 / (dist * dist);
                this.actForce(ang, mag);
            }

            this.isCollide(e);

        }
    }

    this.x += Math.cos(this.angle.value * Math.PI / 180) * this.vel;
    this.y += Math.sin(this.angle.value * Math.PI / 180) * this.vel;

    for (var i = 0; i < entities.length; i++) {
        var e = entities[i];
        if (e != this && e.name == "amino" && distance(e.x, e.y, this.x, this.y) <=this.width + e.width) {
            e.x += Math.cos(this.angle.value * Math.PI / 180) * this.vel;
            e.y += Math.sin(this.angle.value * Math.PI / 180) * this.vel;
        }
    }

    if (this.x < 0) {
        //this.x = 0;
        this.x = 600;
        //this.angle.add(180);
    }
    if (this.x > 600) {
        //this.x = 600;
        this.x = 0;
        //this.angle.add(180);
    }
    if (this.y < 0) {
        //this.y = 0;
        this.y = 600;
        //this.angle.add(180);
    }
    if (this.y > 600) {
        //this.y = 600;
        this.y = 0
        //this.angle.add(180);
    }
}

amino.prototype.actForce = function (angle, mag) {//divide force by mass
    var xvel = Math.cos(this.angle.value * Math.PI / 180) * this.vel;
    var yvel = Math.sin(this.angle.value * Math.PI / 180) * this.vel;

    var newxvel = Math.cos(angle * Math.PI / 180) * mag;
    var newyvel = Math.sin(angle * Math.PI / 180) * mag;

    if (this.id == 0) {
        //console.log(xvel, yvel, this.angle.value, this.vel, Math.atan2(yvel, xvel) * 180/ Math.PI);
    }

    xvel += newxvel;
    yvel += newyvel;

    if (xvel != 0 && yvel != 0) {
        var newAng =  new angleA(Math.atan2(yvel, xvel) * 180/ Math.PI);
        var newmag = Math.sqrt(xvel * xvel + yvel * yvel);
        this.angle.setAngle(newAng.value);
        //this.vel = newmag;
        //console.log(this.vel);
    } else {
        this.vel = 0;
    }

}

function distance(x1, y1, x2, y2) {
    var num = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
    return num;
}

amino.prototype.getX = function() {
    return this.x;
}

amino.prototype.getY = function() {
    return this.y;
}

amino.prototype.isFocus = function() {
    return this.isfocus;
}

amino.prototype.setFocus = function(newFocus) {
    this.isfocus = newFocus;
}

amino.prototype.isCollide = function(other) {
    if (distance(this.getAmineX(), this.getAmineY(), other.getCarboxX(), other.getCarboxY()) <= this.radius * 2) {
        this.angle.setAngle(other.angle.value);
    }

    if (distance(this.getCarboxX(), this.getCarboxY(), other.getAmineX(), other.getAmineY()) <= this.radius * 2) {
        this.angle.setAngle(other.angle.value);
    }
}

amino.prototype.getAmineX = function() {
//this.x *c.scale - this.width/2 * c.scale - c.x, 
    return this.x - this.width/2;
}

amino.prototype.getAmineY = function() {
//this.y *c.scale - c.y
    return this.y;
}

amino.prototype.getCarboxX = function() {
//(this.x *c.scale + this.width/2 * c.scale - c.x
    return this.x + this.width/2;
}

amino.prototype.getCarboxY = function() {
//, this.y *c.scale - c.y
    return this.y;
}

amino.prototype.getSideX = function() {
//this.x *c.scale - c.x,
    return this.x
}

amino.prototype.getSideY = function() {
// this.y *c.scale + this.width/2 * c.scale - c.y
    return this.y + this.width/2;
}
*/

/*
function randomInt(n) {
    return Math.floor(Math.random() * n);
}

function angleA(angle) {
    this.value = angle % 360;
}

angleA.prototype.add = function (add) {
    var newAng = this.value + add;
    this.value = newAng % 360;
}

angleA.prototype.setAngle = function (angle) {
    var newAng = angle % 360;
    this.value = newAng;
}

function nucleotide(x, y, angle = 0, id) {
    this.name = "nucleotide";
    this.x = x;
    this.y = y;
    this.angle = new angleA(angle);
    this.width = 8;
    this.radius = 4;
    this.remove = false;
    this.vel = 1;
    this.isfocus = false;
}

nucleotide.prototype.render = function(ctx) {
    var phos = new Path2D();
    var sugar = new Path2D();
    var base = new Path2D();

    ctx.fillStyle = "white";
    phos.arc(this.x *c.scale-this.width/2 * c.scale - c.x, this.y*c.scale-this.width/2 * c.scale - c.y, this.radius * c.scale, 0, Math.PI * 2);
    ctx.fill(phos);

    ctx.fillStyle = "purple";
    sugar.rect(this.x*c.scale-this.width/2 * c.scale - c.x, this.y*c.scale-this.width/2 * c.scale - c.y, this.width * c.scale, this.width * c.scale);
    ctx.fill(sugar);

    ctx.fillStyle = "yellow";
    base.rect(this.x *c.scale + this.width/2 * c.scale- c.x, this.y*c.scale - c.y, this.radius * c.scale, this.radius * c.scale);
    ctx.fill(base);


    if (this.isfocus) {
        var label = new Path2D();
        label.arc(this.x *c.scale - c.x, this.y *c.scale - c.y, this.width/2 * c.scale, 0, Math.PI * 2);
        ctx.stroke(label);
    }
}

nucleotide.prototype.tick = function(entities) {
    for (var i = 0; i < entities.length; i++) {
        var e = entities[i];
        if (e != this && e.name == "nucleotide") {
            var xdist = e.x - this.x;
            var ydist = e.y - this.y;
            var dist = distance(e.x, e.y, this.x, this.y);
            if (dist != 0) {
                var ang = Math.atan2(ydist, xdist) * 180 / Math.PI;
                var mag = 40 * 1 * 1 / (dist * dist);
                this.actForce(ang, mag);
            }

        }
    }

    this.x += Math.cos(this.angle.value * Math.PI / 180) * this.vel;
    this.y += Math.sin(this.angle.value * Math.PI / 180) * this.vel;


    for (var i = 0; i < entities.length; i++) {
        var e = entities[i];
        if (e != this && e.name == "nucleotide" && distance(e.x, e.y, this.x, this.y) <=this.width + e.width) {
            e.x += Math.cos(this.angle.value * Math.PI / 180) * this.vel;
            e.y += Math.sin(this.angle.value * Math.PI / 180) * this.vel;
        }
    }


    if (this.x < 0) {
        //this.x = 0;
        this.x = 600;
        //this.angle.add(180);
    }
    if (this.x > 600) {
        //this.x = 600;
        this.x = 0;
        //this.angle.add(180);
    }
    if (this.y < 0) {
        //this.y = 0;
        this.y = 600;
        //this.angle.add(180);
    }
    if (this.y > 600) {
        //this.y = 600;
        this.y = 0
        //this.angle.add(180);
    }

}

nucleotide.prototype.actForce = function (angle, mag) {//divide force by mass
    var xvel = Math.cos(this.angle.value * Math.PI / 180) * this.vel;
    var yvel = Math.sin(this.angle.value * Math.PI / 180) * this.vel;

    var newxvel = Math.cos(angle * Math.PI / 180) * mag;
    var newyvel = Math.sin(angle * Math.PI / 180) * mag;

    if (this.id == 0) {
        //console.log(xvel, yvel, this.angle.value, this.vel, Math.atan2(yvel, xvel) * 180/ Math.PI);
    }

    xvel += newxvel;
    yvel += newyvel;

    if (xvel != 0 && yvel != 0) {
        var newAng =  new angleA(Math.atan2(yvel, xvel) * 180/ Math.PI);
        var newmag = Math.sqrt(xvel * xvel + yvel * yvel);
        this.angle.setAngle(newAng.value);
        //this.vel = newmag;
        //console.log(this.vel);
    } else {
        this.vel = 0;
    }

}

nucleotide.prototype.getX = function() {
    return this.x;
}

nucleotide.prototype.getY = function() {
    return this.y;
}

nucleotide.prototype.isFocus = function() {
    return this.isfocus;
}

nucleotide.prototype.setFocus = function(newFocus) {
    this.isfocus = newFocus;
}
*/
/*

function camera(x, y, follow) {
    console.log("Camera created");
    this.x = x;
    this.y = y;
    this.follow = follow;
    this.isRemove = false;
    this.focus = false;
    this.scale = .5;
    if (follow != null) {
        console.log("follow" ,follow.x, follow.y);
        this.x = follow.x;
        this.y = follow.y;
    }
}

camera.prototype.tick = function() {
    this.x = 0;
    this.y = 0;

    //this.x = (this.follow.x - 600/2) * this.scale + 600/2;//board.width
    //this.y = (this.follow.y - 600/2) * this.scale + 600/2;

    //this.x = (this.follow.x * this.scale - (600/2 * 1));//board.width
    //this.y = (this.follow.y * this.scale - (600/2 * 1));

    //this.scale -= .005;
    if (this.scale <= 0) {
        this.scale = .005;
    }

}

camera.prototype.render = function(ctx) {

}


camera.prototype.setFocus = function(focus) {
    this.focus = focus;

}
*/

   /*
        for (var i = 0; i < entities.length; i++) {
            var e = entities[i];
            if (e != this && e.name == "Fatty" && this.isCollide(e)) {
                var dist = Calc.distance(this.x, this.y, e.x, e.y);
                var delta = this.length / 2 + this.radius * this.headScale + e.length / 2 + e.radius * e.headScale - dist;
                var difX = (this.x - e.x) / dist;
                var difY = (this.y - e.y) / dist;
 
                this.x += difX * delta / 2;
                this.y += difY * delta / 2;
                e.x -= difX * delta / 2;
                e.y -= difY * delta / 2;
                //swap vels
                var tempSpeed = this.speed;
                var tempAng = this.d_angle.value;
                this.speed = e.speed;
                this.d_angle.setValue(e.d_angle.getValue());
                e.speed = tempSpeed;
                e.d_angle.setValue(tempAng);
 
                isc = true;
                //act forces only from colliding lipids
                var xdist = e.getX() - this.getX();
                var ydist = e.getY() - this.getY();
                var dist = Calc.distance(this.getTailX(), this.getTailY(), e.getTailX(), e.getTailY());
                if (ydist != 0 && xdist != 0) {// && dist > this.radius
                    var ang = Math.atan2(-ydist, -xdist) * 180 / Math.PI;
                    var mag = 20 * 1 * 1 / (dist * dist);
                    e.actForce(ang, mag);
                } else {
                    //console.log("need something");
                    // var ang = Math.atan2(ydist, xdist) * 180 / Math.PI + 180;
                    // var mag = 40 * 1 * 1 / (dist * dist);
                    // this.actForce(ang, mag);
                }
 
                var xdist2 = e.getHeadX() - this.getHeadX();
                var ydist2 = e.getHeadY() - this.getHeadY();
                var dist2 = Calc.distance(this.getHeadX(), this.getHeadY(), e.getHeadX(), e.getHeadY());
                if (ydist2 != 0 && xdist2 != 0) {//and not head colliding
                    var ang = Math.atan2(-ydist2, -xdist2) * 180 / Math.PI;
                    var mag = 2 * 1 * 1 / (dist2 * dist2);
                    e.forceHead(ang, mag);
                } else {
                    //console.log("need something");
                }
 
            }
        }
 
        if (true) {//!isc
            for (var i = 0; i < entities.length; i++) {
                var e = entities[i];
                if (e != this && e.name == "Fatty" && !isc) {
                    var xdist = e.getX() - this.getX();
                    var ydist = e.getY() - this.getY();
                    var dist = Calc.distance(this.getTailX(), this.getTailY(), e.getTailX(), e.getTailY());
                    if (ydist != 0 && xdist != 0) {// && dist > this.radius
                        var ang = Math.atan2(-ydist, -xdist) * 180 / Math.PI;
                        var mag = 20 * 1 * 1 / (dist * dist);
                        e.actForce(ang, mag);
                    } else {
                        //console.log("need something");
                        // var ang = Math.atan2(ydist, xdist) * 180 / Math.PI + 180;
                        // var mag = 40 * 1 * 1 / (dist * dist);
                        // this.actForce(ang, mag);
                    }
                    var xdist2 = e.getHeadX() - this.getHeadX();
                    var ydist2 = e.getHeadY() - this.getHeadY();
                    var dist2 = Calc.distance(this.getHeadX(), this.getHeadY(), e.getHeadX(), e.getHeadY());
                    if (ydist2 != 0 && xdist2 != 0) {//and not head colliding
                        var ang = Math.atan2(-ydist2, -xdist2) * 180 / Math.PI;
                        var mag = 2 * 1 * 1 / (dist2 * dist2);
                        e.forceHead(ang, mag);
                    } else {
                        //console.log("need something");
                    }
 
                    var xdist3 = e.getTailX() - this.getHeadX();
                    var ydist3 = e.getTailY() - this.getHeadY();
                    var dist3 = Calc.distance(this.getHeadX(), this.getHeadY(), e.getHeadX(), e.getHeadY());
                    if (ydist3 != 0 && xdist3 != 0) {
                        var ang = Math.atan2(ydist3, xdist3) * 180 / Math.PI;
                        var mag = 1 * 1 * 1 / (dist3 * dist3);
                        e.actForce(ang, mag);//keep head and tail apart
                    } else {
                        //console.log("need something");
                    }
 
                }
            }
 
        }
        */